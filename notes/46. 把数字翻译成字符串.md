# 46. 把数字翻译成字符串

[Leetcode](https://leetcode.com/problems/decode-ways/description/)

## 题目描述

给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。例如，对于数字 12258，可以翻译成多个字符串：abbeh、lbeh、aveh、abyh 和 lyh，总共 5 种不同的翻译方式。请实现一个函数，计算一个数字有多少种不同的翻译方法。

## 解题思路

要解决这个问题，我们可以使用动态规划的方法来计算不同的翻译方式的数量。下面是我们用来实现这个想法的步骤：

1. **定义状态**：用一个数组 `dp` 来存储到达每个位置的解码方式的数量。`dp[i]` 表示前 `i` 个字符可以解码的方式总数。

2. **初始化状态**：
   - `dp[0] = 1`，表示空字符串有一种解码方式（即不解码）。
   - `dp[1]` 的值取决于第一个字符是否为 '0'：
     - 如果是 '0'，那么不可能进行解码，所以 `dp[1] = 0`。
     - 如果不是 '0'，则 `dp[1] = 1`，代表只有一种解码对应。

3. **填充状态数组**：
   - 从第二个字符开始迭代到最后一个字符（即从 `i = 2` 到 `n`）。
   - 对于每个字符，检查它是否单独可以成一个有效数字（即不是 '0'），如果有效，则从 `dp[i-1]` 中继承其解码计数。
   - 同时检查当前字符和前一个字符是否组合（即两个字符形成的数字在 1 到 26 之间）。如果可以组合，则从 `dp[i-2]` 中添加解码计数。

4. **返回结果**：最后，返回 `dp[n]`，即完整字符串的解码方式总数。

以下是实现这个逻辑的 Java 代码：

```java
public int numDecodings(String s) {
    // 边界条件判断，空字符串直接返回0
    if (s == null || s.length() == 0) {
        return 0;
    }
    
    int n = s.length();
    int[] dp = new int[n + 1];
    
    // 初始化
    dp[0] = 1; // 空字符串
    dp[1] = s.charAt(0) == '0' ? 0 : 1; // 非零字符初始化
    
    // 动态规划填表
    for (int i = 2; i <= n; i++) {
        // 获取当前字符
        int one = Integer.valueOf(s.substring(i - 1, i));
        // 判断当前字符是否有效
        if (one != 0) {
            dp[i] += dp[i - 1]; // 加上前一个位置的解码方式
        }
        
        // 获取前一个字符
        if (s.charAt(i - 2) == '0') {
            continue; // 前一个字符无效，跳过
        }
        
        int two = Integer.valueOf(s.substring(i - 2, i));
        // 判断前两个字符是否有效组合
        if (two <= 26) {
            dp[i] += dp[i - 2]; // 加上前两个位置的解码方式
        }
    }
    
    return dp[n]; // 返回完整字符串的解码方式总数
}
```

### 代码分析

- **时间复杂度**：O(n)，其中 n 是字符串的长度。我们只进行了一次线性遍历。
- **空间复杂度**：O(n)，需要一个数组来存储解码方式的计数。不过，我们可以用两个变量优化空间复杂度到 O(1)。

通过以上步骤，我们能够有效地计算出数字翻译成字符串的不同方式，从而解决此问题。