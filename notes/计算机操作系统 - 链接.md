# 计算机操作系统 - 链接

<!-- GFM-TOC -->
* [计算机操作系统 - 链接](#计算机操作系统---链接)
    * [编译系统](#编译系统)
    * [静态链接](#静态链接)
    * [目标文件](#目标文件)
    * [动态链接](#动态链接)
<!-- GFM-TOC -->

## 编译系统

下面是一个简单的 `hello.c` 程序示例：

```c
#include <stdio.h>

int main() {
    printf("hello, world\n");
    return 0;
}
```

在 Unix 系统中，编译器将源文件转换为目标文件的过程如下，通常可以通过以下命令完成：

```bash
gcc -o hello hello.c
```

此过程大致分为四个阶段：

1. **预处理阶段**：处理以 `#` 开头的预处理命令，诸如头文件的包含、宏定义的替换等。
2. **编译阶段**：将预处理生成的代码翻译成汇编语言。
3. **汇编阶段**：将汇编语言代码翻译为可重定位目标文件，这个文件包含了机器码但尚未链接。
4. **链接阶段**：链接器将可重定位目标文件与其他单独编译的目标文件（如 `printf.o`）进行合并，生成最终的可执行文件。

<div align="center"> 
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> 
</div><br>

## 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完整链接的可执行目标文件作为输出。链接器的主要功能包括：

- **符号解析**：每个符号对应一个函数、全局变量或静态变量。符号解析的目的是将每个符号的引用与其定义关联起来，这样程序在执行时才能正确找到所需的函数或变量。
- **重定位**：链接器通过将每个符号定义与特定的内存地址关联，同时修改所有对这些符号的引用，使它们指向正确的内存位置。

<div align="center"> 
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> 
</div><br>

## 目标文件

目标文件主要分为以下三种类型：

- **可执行目标文件**：可以直接在内存中执行，是最终用户交互的程序。
- **可重定位目标文件**：可以与其他可重定位目标文件在链接阶段合并，生成一个可执行目标文件。这种文件独立于程序，可被多个程序共享使用。
- **共享目标文件**：这是一种特殊的可重定位目标文件，可以在程序运行时动态加载到内存中并链接，提升了资源的有效利用。

## 动态链接

使用静态库时，存在以下两个主要问题：

1. **更新问题**：当静态库更新时，所有依赖于该库的程序都必须重新进行链接，这显著增加了开发和部署的复杂性。
2. **资源浪费**：例如，对于 `printf` 函数等标准库函数，如果每个程序都包含这些代码，会造成很大的内存和存储资源浪费。

共享库的设计旨在解决静态库的这两个问题。在 Linux 系统中，通常用 `.so` 后缀表示共享库，而在 Windows 系统上则称为 DLL（动态链接库）。共享库的特点包括：

- 在文件系统中，某个共享库只需有一个文件，所有引用该库的可执行文件共享这一单一副本，而不必在每个可执行文件中复制该库。
- 在内存中，不同的正在运行的进程可以共享同一个共享库的 `.text` 段（已编译程序的机器代码），因此减少了内存使用和提高了系统资源的利用率。

<div align="center"> 
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> 
</div><br>