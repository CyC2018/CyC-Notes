[Leetcode](https://leetcode.com/problems/target-sum/description/)

```html
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
```

该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。\
可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：
```html
                  sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)
```
因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。\
**弄懂题意**\
第一步需要根据题意考虑输出的结构，在【416.分割等和子集】这道题中，要求的输出结果就是boolean值，因此我们定义的dp数组只需要记录T/F即可，但是这道题要求返回结果是方法数，那么我们dp数组需要记录的数据就是具体的方法数。\
**定义状态**\
搞清楚需要输出的结果后，就可以来想办法画一个表格，也就是定义dp数组的含义。根据背包问题的经验，可以将dp[ i ][ j ]定义为从数组nums中 0 - i 的元素进行加减可以得到 j 的方法数量。分两种情况：
1. `j>= nums[i-1]`时，我既可以选这个数`nums[i-1]`，那我就看我之前所有数有多少种方法能正好凑到`j-nums[i-1]`，我也可以不选，那我就看我之前所有数有多少种方法能正好凑到j。这两种情况加起来就是`dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]`。
2. `j<nums[i-1]`时，我不可能选这个数（选了就暴表了），我只能看我不选这个数，我之前所有数有多少种方法能正好凑到j。用这一种情况更新就是`dp[i][j] = dp[i-1][j]`。
## dp (0-1 knapsack)
```java

```
