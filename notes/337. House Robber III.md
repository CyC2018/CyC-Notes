[Leetcode](https://leetcode.com/problems/house-robber-iii/)

## dp(hashmap)
```java

```

## dfs
```java
class Solution {
    int res = 0;
    public int rob(TreeNode root) {
        if (root == null) return 0;
        return dfs(root);
    }
    private int dfs(TreeNode node) {
        if (node == null) return 0;
        int include = node.val;
        if (node.left != null) include += dfs(node.left.left) + dfs(node.left.right);
        if (node.right != null) include += dfs(node.right.left) + dfs(node.right.right);
        int notInclude = 0;
        notInclude += dfs(node.left) + dfs(node.right);
        return Math.max(include, notInclude);
    }
}
```
看出来上面解法有很多重复的递归，用memo来记住已经计算过的结果。运行速度从671ms提升到2ms！:triumph:（这感觉就像Lebron James完成了一记暴扣一样，解气）
```java
class Solution {
    int res = 0;
    HashMap<TreeNode, Integer> memo = new HashMap<>();
    public int rob(TreeNode root) {
        if (root == null) return 0;
        return dfs(root);
    }
    private int dfs(TreeNode node) {
        if (node == null) return 0;
        if (memo.containsKey(node)) return memo.get(node);
        int include = node.val;
        if (node.left != null) include += dfs(node.left.left) + dfs(node.left.right);
        if (node.right != null) include += dfs(node.right.left) + dfs(node.right.right);
        int notInclude = 0;
        notInclude += dfs(node.left) + dfs(node.right);
        memo.put(node, Math.max(include, notInclude));
        return Math.max(include, notInclude);
    }
}
```
还有更漂亮的解法。每个node返回两个变量，cur[0]表示不抢当前的，cur[1]表示抢当前的。这样**只需递归到下一层节点即可，不需要递归到下下层节点**，所以没有重复计算，所以不需要用备忘录memo！间复杂度只有递归函数堆栈所需的空间，不需要备忘录的额外空间。

你看他和我们的思路不一样，修改了递归函数的定义，略微修改了思路，使得逻辑自洽，依然得到了正确的答案，而且代码更漂亮。这就是我们前文「不同定义产生不同解法」所说过的动态规划问题的一个特性。
```java
class Solution {
    public int rob(TreeNode root) {
        if (root == null) return 0;
        int[] res = dfs(root);
        return Math.max(res[0], res[1]);
    }
    private int[] dfs(TreeNode node) {
        // 对于null，抢和不抢都是0
        if (node == null) return new int[2];
        // 左子树
        int[] left = dfs(node.left);
        // 右子树
        int[] right = dfs(node.right);
        // 定义待返回数组
        int[] cur = new int[2];
        // 不抢，下家我可以选择抢或不抢
        cur[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        // 抢，下家只能选择不抢
        cur[1] = node.val + left[0] + right[0];
        // 返回结果
        return cur;
    }
}
```
