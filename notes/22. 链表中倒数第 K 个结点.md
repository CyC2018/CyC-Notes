# 22. 链表中倒数第 K 个结点

## 解题思路

设定链表的长度为 \(N\)。为了找到倒数第 \(K\) 个结点，我们可以使用两个指针 \(P1\) 和 \(P2\)。首先让指针 \(P1\) 向前移动 \(K\) 个节点，这样在此时链表中还有 \(N - K\) 个节点未被访问到。

### 过程说明

1. **初始设置**：
   - 检查链表的头结点是否为空。如果链表为空，直接返回 `null`。
   - 定义两个指针 \(P1\) 和 \(P2\)，开始时都指向链表的头部。

2. **移动指针 \(P1\)**：
   - 将指针 \(P1\) 向前移动 \(K\) 个节点。在这个过程中，每移动一个节点，\(K\) 的值减一。
   - 如果在移动 \(K\) 个节点后，\(K\) 的值仍然大于 0，说明链表的长度小于 \(K\)，此时返回 `null`，表示没有找到倒数第 \(K\) 个结点。

3. **同时移动 P1 和 P2**：
   - 此时让 \(P1\) 和 \(P2\) 同时移动，直到 \(P1\) 到达链表的结尾（即 \(P1\) 为 `null`）。
   - 在这个过程中，\(P2\) 将会移动到链表的第 \(N - K\) 个节点。此时，\(P2\) 就是我们要找的倒数第 \(K\) 个节点。

### 示例图解

当链表节点顺序为 `1 -> 2 -> 3 -> 4 -> 5`，要找到倒数第 2 个节点的过程如下图所示：

```
P1移动K个节点后：
1 -> 2 -> 3 -> 4 -> 5  (P1)
                ↑
               P2
               
同时移动P1和P2直至P1到达链表结尾：
       P1
       ↓
1 -> 2 -> 3 -> 4 -> 5
                ↑
               P2
               
返回P2节点，即值为4的节点。
```

### 代码实现

下面是相应的Java代码实现，注释清晰明了：

```java
public class ListNode {
    int val; // 节点的值
    ListNode next; // 指向下一个节点的指针

    ListNode(int x) {
        val = x;
        next = null;
    }
}

public ListNode FindKthToTail(ListNode head, int k) {
    // 如果链表为空，直接返回null
    if (head == null) {
        return null;
    }

    ListNode P1 = head; // 指针P1初始化为头结点
    // 移动P1 K个节点
    while (P1 != null && k-- > 0) {
        P1 = P1.next;
    }
    
    // 如果k仍然大于0，说明链表长度小于K，返回null
    if (k > 0) {
        return null;
    }
    
    ListNode P2 = head; // 指针P2初始化为头结点
    // 同时移动P1和P2，直到P1到达链表结尾
    while (P1 != null) {
        P1 = P1.next;
        P2 = P2.next;
    }
    
    return P2; // 返回P2所指向的节点，作为倒数第K个节点
}
```

### 总结
以上算法的时间复杂度为 \(O(N)\)，空间复杂度为 \(O(1)\)。通过两个指针的巧妙使用，能够有效地找到链表中倒数第 \(K\) 个节点。