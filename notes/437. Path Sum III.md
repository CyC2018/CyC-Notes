[Leetcode](https://leetcode.com/problems/path-sum-iii/)

## dfs
```java
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    }
    private int pathSumFrom(TreeNode node, int sum) {
        sum -= node.val;
        int res = 0;
        if (sum == 0) res++;
        if (node.left != null) res += pathSumFrom(node.left, sum);
        if (node.right != null) res += pathSumFrom(node.right, sum);
        return res;
    }
}
```

## dfs + hashmap(prefix sum) + backtracking
[**参考文章**](https://leetcode.com/problems/path-sum-iii/discuss/91878/17-ms-O(n)-java-Prefix-sum-method)\
用一句话总结就是每条path都维护一个prefix sum在`map`中（类似two sum那题），但为了重复利用prefix sum，我们用backtracking把当前node的sum在`map`中去掉。\
The idea is based on path.\
Suppose now the hash table `map` stores the prefix sum of the whole path. Then after adding current node's val to the pathsum, if (pathsum-target) is in the `map`, then we know that at some node of path we have a (pathsum-target) total sum, hence we have a path of target. Actually, it is the path starting from that node.\
Now the problem is how to maintain this prefix sum table? Since one path's prefix sum table is different from others, we have to change it. However, we should notice that we can reuse the most part of the prefix sum table. If we are done with current node, we just need to delete the current pathsum in the preSum, and leave all other prefix sum in it. Then, in higher layers, we can forget everything about this node (and its descendants).\
That's why we have`map.put(sum, preSum.get(sum) - 1);`.This deletes current pathsum and leave all previous prefix sums.
```java
class Solution {
    HashMap<Integer, Integer> count = new HashMap<>();
    public int pathSum(TreeNode root, int sum) {
        if (root == null) return 0;
        count.put(0, 1);
        return helper(root, 0, sum);
    }
    private int helper(TreeNode root, int curSum, int target) {
        if (root == null) return 0;
        curSum += root.val;
        int res = count.getOrDefault(curSum - target, 0);
        count.put(curSum, count.getOrDefault(curSum, 0) + 1);
        res += helper(root.left, curSum, target) + helper(root.right, curSum, target);
        count.put(curSum, count.get(curSum) - 1);
        return res;
    }
}
```
