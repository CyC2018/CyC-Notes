[Leetcode](https://leetcode.com/problems/permutations-ii/)

这道题，不论用任何递归方法时，请记住当前位置千万别插入重复的元素！！

不管你用递归一个一个加入元素，还是跟剩下的元素一个一个互换，只要当前递归层里（也就是当前位置）的相同元素出现了两次，你再递归下去，递归树就重复走到之前走过的path了！

再强调一遍，你递归时，不管是insert还是swap，你在当前层的主要任务，就是**固定一个数**！不要在同一个位置固定相同的数！:triumph:


## dfs(inserting different elements) + backtracking
```java

```

## dfs(swaping with other elements) + backtracking
```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        if (nums == null || nums.length == 0) return res;
        dfs(nums, 0);
        return res;
    }
    private void dfs(int[] nums, int index) {
        if (index == nums.length) {
            res.add(toList(nums));
            return;
        }
        for (int i = index; i < nums.length; i++) {
            // 检查后面是否有跟当前准备互换的元素相同的元素，如果有则不换（只换最后出现的一次）
            // 也可以检查前面（从index到i-1）是否遇到过跟准备要换的nums[i]相同的元素
            boolean duplicated = false;
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == nums[i]) duplicated = true;
            }
            if (duplicated == true) continue;
            // 常规逻辑
            swap(nums, index, i);
            dfs(nums, index + 1);
            swap(nums, index, i);
        }
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    private List<Integer> toList(int[] nums) {
        List<Integer> partial = new ArrayList<>();
        for (int num : nums) {
            partial.add(num);
        }
        return partial;
    }
}
```
