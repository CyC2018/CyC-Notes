[Leetcode](https://leetcode.com/problems/perfect-squares/)

## bfs

```java
class Solution {
    public int numSquares(int n) {
        // 生成邻接图或方向数组，这里squares其实相当于方向数组
        List<Integer> squares = genSquares(n);
        // 定义标记数组，避免重复到达同一个node，如果是in-place那就用不着这个
        boolean[] marked = new boolean[n + 1];
        // 定义队列
        Queue<Integer> queue = new LinkedList<>();
        // 加入第一个node并标记
        queue.add(n);
        marked[n] = true;
        // 定义当前路径长度
        int len = 0;
        // 开始循环
        while (!queue.isEmpty()) {
            // 记录当前大小
            int size = queue.size();
            // 清空当前大小队列并且最后当前路径加1
            for (int i = 0; i < size; i++) {
                // 每次提取一个
                int cur = queue.poll();
                // 查看是否已到达终点
                if (cur == 0) {
                    return len;
                }
                // 不是终点则开始探索各个方向
                for (int s : squares) {
                    // 计算下一个node
                    int next = cur - s;
                    // 根据需要剪枝
                    if (next < 0) break;
                    // 如果下一个node满足所有限制条件且未到达过，则加入队列并且标记已到达过
                    if (next >= 0 && marked[next] == false) {
                        queue.add(next);
                        marked[next] = true;
                    }
                }
            }
            // 路径长度加1
            len++;
        }
        // 如果找不到合法路径就返回一个数
        return -1;
    }
    
    private List<Integer> genSquares(int n) {
        List<Integer> squares = new ArrayList<>();
        int square = 1;
        int diff = 3;
        while (square <= n) {
            squares.add(square);
            square += diff;
            diff += 2;
        }
        return squares;
    }
}
```

## dynamic programming

我们还可以用动态规划来做，我们建立一个长度为 n+1 的一维dp数组，将第一个值初始化为0，其余值都初始化为`Integer.MAX_VALUE`, i从1循环到n，其中 dp[i] 表示正整数i最少能由多个完全平方数组成，那么我们求n，就是返回 dp[n] 即可，也就是 dp 数组的最后一个数字。

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; i - j * j >= 0; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}
```
