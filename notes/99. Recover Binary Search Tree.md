[Leetcode](https://leetcode.com/problems/recover-binary-search-tree/)

## recursive in-order traversal + pre(storing previous node) + first + second(storing nodes to be swapped)
中序遍历按道理来说是从小到大的1234567，如果我随便换两个数2和6，那么我中序遍历的时候会发现两处地方不对劲，1634527，就是6比3大，还有5比2大，怎么换才能把它变回递增数列（修正成合法BST）呢？第一个冲突选大，第二个冲突选小。
```java
class Solution {
    // 中序遍历按道理来说是从小到大的1234567，如果我随便换两个数2和6，那么我中序遍历的时候会发现两处地方不对劲
    // 1634527，就是6比3大，还有5比2大，怎么换才能把它变回递增数列（修正成合法BST）呢？第一个冲突选大，第二个冲突选小
    List<Integer> list = new ArrayList<>();
    TreeNode pre = null, first = null, second = null;
    public void recoverTree(TreeNode root) {
        if (root == null) return;
        // 开始中序遍历
        inOrder(root);
        System.out.println(list);
        // 交换两个错误的数
        if (first != null && second != null) {
            int temp = first.val;
            first.val = second.val;
            second.val = temp;
        }
    }
    // 中序遍历
    private void inOrder(TreeNode node) {
        if (node.left != null) inOrder(node.left);
        // 如果pre比我大，那就不对劲
        if (pre != null && pre.val > node.val) {
            System.out.println("pre:"+pre.val+",node:"+node.val);
            first = first == null ? pre : first;
            second = node;
        }
        list.add(node.val);
        // 更新pre
        pre = node;
        if (node.right != null) inOrder(node.right);
    }
}
```
## morris traversal
这道题的真正符合要求的解法应该用的 Morris 遍历，这是一种非递归且不使用栈，空间复杂度为 O(1) 的遍历方法，可参见博主之前的博客 Binary Tree Inorder Traversal，在其基础上做些修改，加入 first, second 和 parent 指针，来比较当前节点值和中序遍历的前一节点值的大小，跟上面递归算法的思路相似。
```c++
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *first = nullptr, *second = nullptr, *cur = root, *pre = nullptr ;
        while (cur) {
            if (cur->left){
                TreeNode *p = cur->left;
                while (p->right && p->right != cur) p = p->right;
                if (!p->right) {
                    p->right = cur;
                    cur = cur->left;
                    continue;
                } else {
                    p->right = NULL;
                }  
            }
            if (pre && cur->val < pre->val){
              if (!first) first = pre;
              second = cur;
            }
            pre = cur;
            cur = cur->right;
        }
        swap(first->val, second->val);
    }
};
```
