[Leetcode](https://leetcode.com/problems/median-of-two-sorted-arrays/)

## binary search
这篇文章讲的通俗易懂，求中位数位置的小技巧蛮赞，但是这个模板不太通用，原因是midVal1等于midVal2时一定要j前进（没搞懂）：https://www.cnblogs.com/grandyang/p/4465932.html

只不过看起来不太像二分搜索，但是每次加k/2其实也是二分搜索，里面用到一个小技巧是分别求第(m+n+1)/2和第(m+n+2)/2个的值然后相加除以2就可以无视m+n的奇偶性都能得到中位数的值。\
其实，这题跟一个数组二分搜索区别在于，这个是搜位置，不是搜值。因为两个数组找k个数出来，要么是第一个数组多拿出一点数，要么第二个数组多拿出一点数，所以要以两个数组之间k/2位置的值来比较，看看是否找到一个平衡。
```java
class Solution {
    int m;
    int n;
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        m = nums1.length;
        n = nums2.length;
        return (findKth(nums1, 0, nums2, 0, (m + n + 1) / 2) + 
            findKth(nums1, 0, nums2, 0, (m + n + 2) / 2)) / 2.0;
    }
    private int findKth(int[] nums1, int i, int[] nums2, int j, int k) {
        if (i >= m) return nums2[j + k - 1];
        if (j >= n) return nums1[i + k - 1];
        if (k == 1) return Math.min(nums1[i], nums2[j]);
        int midVal1 = (i + k / 2 - 1 < m) ? nums1[i + k / 2 - 1] : Integer.MAX_VALUE;
        int midVal2 = (j + k / 2 - 1 < n) ? nums2[j + k / 2 - 1] : Integer.MAX_VALUE;
        if (midVal1 < midVal2) {
            return findKth(nums1, i + k / 2, nums2, j, k - k / 2);
        } else {
            return findKth(nums1, i, nums2, j + k / 2, k - k / 2);
        }
    }
}
```
这个模板更像二分搜索一点
```java

```
## max heap + min heap
```java

```
