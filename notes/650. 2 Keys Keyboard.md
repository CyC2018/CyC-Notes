[Leetcode](https://leetcode.com/problems/2-keys-keyboard/submissions/)

## dp
本解法关键就在于找最大公因数，参考文章：https://leetcode-cn.com/problems/2-keys-keyboard/solution/bao-li-dptong-su-yi-dong-by-william-43/

也可以把`i/j`换成`dp[i/j]`，参考文章：https://leetcode-cn.com/problems/2-keys-keyboard/solution/dong-tai-gui-hua-fa-javashi-xian-by-zyu/
```java
class Solution {
    public int minSteps(int n) {
        if (n == 1) return 0;
        int[] dp = new int[n + 1];
        dp[1] = 0;
        for (int i = 2; i <= n; i++) dp[i] = i;
        for (int i = 2; i <= n; i++) {
            for (int j = i / 2; j >= 2; j--) {
                if (i % j == 0) {
                    dp[i] = Math.min(dp[i], dp[j] + i / j);
                    break;
                }
            }
        }
        return dp[n];
    }
}
```

## math(finding the Greatest Common Divisor, GCD) + recursion 
参考文章：https://leetcode-cn.com/problems/2-keys-keyboard/solution/cshu-xue-by-pirlo/

如果n是质数，则只能一个个复制粘贴，结果就是n。\
寻找n的最大因子i，先得到i，然后复制1次，粘贴n/i - 1次，因此steps[n] = steps[i] + n/i。
```java
class Solution {
    public int minSteps(int n) {
        if (n == 1) return 0;
        for (int i = n / 2; i >= 2; i--) {
            if (n % i == 0) {
                return minSteps(i) + n / i;
            }
        }
        return n;
    }
}
```
